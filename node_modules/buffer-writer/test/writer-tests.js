const { Writer } = require('../');
const assert = require('assert');
const util = require('util');

const assertEqualBuffers = (actual, expected) => {
  const spit = (actual, expected) => {
    console.log('');
    console.log(`actual ${util.inspect(actual)}`);
    console.log(`expect ${util.inspect(expected)}`);
    console.log('');
  };
  if (actual.length !== expected.length) {
    spit(actual, expected);
    assert.strictEqual(actual.length, expected.length);
  }
  for (let i = 0; i < actual.length; i++) {
    if (actual[i] !== expected[i]) {
      spit(actual, expected);
    }
    assert.strictEqual(actual[i], expected[i]);
  }
};

suite('adding int32', () => {
  const testAddingInt32 = (int, expectedBuffer) =>
    test(`writes ${int}`, () => {
      const subject = new Writer();
      const result = subject.addInt32(int).join();
      assertEqualBuffers(result, expectedBuffer);
    });

  testAddingInt32(0, [0, 0, 0, 0]);
  testAddingInt32(1, [0, 0, 0, 1]);
  testAddingInt32(256, [0, 0, 1, 0]);
  test('writes largest int32', () => {
    //todo need to find largest int32 when I have internet access
    return false;
  });

  test('writing multiple int32s', () => {
    const subject = new Writer();
    const result = subject.addInt32(1).addInt32(10).addInt32(0).join();
    assertEqualBuffers(result, [0, 0, 0, 1, 0, 0, 0, 0x0a, 0, 0, 0, 0]);
  });

  suite('having to resize the buffer', () => {
    test('after resize correct result returned', () => {
      const subject = new Writer(10);
      subject.addInt32(1).addInt32(1).addInt32(1);
      assertEqualBuffers(subject.join(), [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]);
    });
  });
});

suite('int16', () => {
  test('writes 0', () => {
    const subject = new Writer();
    const result = subject.addInt16(0).join();
    assertEqualBuffers(result, [0, 0]);
  });

  test('writes 400', () => {
    const subject = new Writer();
    const result = subject.addInt16(400).join();
    assertEqualBuffers(result, [1, 0x90]);
  });

  test('writes many', () => {
    const subject = new Writer();
    const result = subject.addInt16(0).addInt16(1).addInt16(2).join();
    assertEqualBuffers(result, [0, 0, 0, 1, 0, 2]);
  });

  test('resizes if internal buffer fills up', () => {
    const subject = new Writer(3);
    const result = subject.addInt16(2).addInt16(3).join();
    assertEqualBuffers(result, [0, 2, 0, 3]);
  });

});

suite('cString', () => {
  test('writes empty cstring', () => {
    const subject = new Writer();
    const result = subject.addCString('').join();
    assertEqualBuffers(result, [0]);
  });

  test('writes two empty cstrings', () => {
    const subject = new Writer();
    const result = subject.addCString('').addCString('').join();
    assertEqualBuffers(result, [0, 0]);
  });


  test('writes non-empty cstring', () => {
    const subject = new Writer();
    const result = subject.addCString('!!!').join();
    assertEqualBuffers(result, [33, 33, 33, 0]);
  });

  test('resizes if reached end', () => {
    const subject = new Writer(3);
    const result = subject.addCString('!!!').join();
    assertEqualBuffers(result, [33, 33, 33, 0]);
  });

  test('writes multiple cstrings', () => {
    const subject = new Writer();
    const result = subject.addCString('!').addCString('!').join();
    assertEqualBuffers(result, [33, 0, 33, 0]);
  });

});

test('writes char', () => {
  const subject = new Writer(2);
  const result = subject.addChar('a').addChar('b').addChar('c').join();
  assertEqualBuffers(result, [0x61, 0x62, 0x63]);
});

test('gets correct byte length', () => {
  const subject = new Writer(5);
  assert.strictEqual(subject.getByteLength(), 0);
  subject.addInt32(0);
  assert.strictEqual(subject.getByteLength(), 4);
  subject.addCString("!");
  assert.strictEqual(subject.getByteLength(), 6);
});

test('can add arbitrary buffer to the end', () => {
  const subject = new Writer(4);
  subject.addCString("!!!")
  const result = subject.add(Buffer.from("@@@")).join();
  assertEqualBuffers(result, [33, 33, 33, 0, 
