const debug = require('debug');

// Expose `debug()` as the module.
module.exports = debug;
module.exports.log = log;
module.exports.formatArgs = formatArgs;
module.exports.save = save;
module.exports.load = load;
module.exports.useColors = useColors;

const colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Determine if the current environment is web-based.
 *
 * @returns {boolean}
 */
function isWeb() {
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
}

/**
 * Determine if the current environment supports "%c" CSS customizations.
 *
 * @returns {boolean}
 */
function useColors() {
  return isWeb() || (
    typeof document !== 'undefined' &&
    document.documentElement &&
    document.documentElement.style &&
    document.documentElement.style.WebkitAppearance
  ) || (
    typeof window !== 'undefined' &&
    window.console && (
      window.console.firebug ||
      (window.console.exception && window.console.table)
    )
  ) || (
    typeof navigator !== 'undefined' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
    parseInt(RegExp.$1, 10) >= 31
  ) || (
    typeof navigator !== 'undefined' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
  );
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
module.exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @param {Array} args
 */
function formatArgs(args) {
  const useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') +
    this.namespace +
    (useColors ? ' %c' : ' ') +
    args[0] +
    (useColors ? '%c ' : ' ') +
    '+' + exports.humanize(this.diff);

  if (!useColors) return;

  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @param {...*} args
 */
function log() {
  if ('object' === typeof console && console.log && Function.prototype.apply.call) {
    Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * Save `namespaces`.
 *
 * @param {string|null} namespaces
 */
function save(namespaces) {
  try {
    if (null == namespaces) {
      module.exports.storage.removeItem('debug');
    } else {
      module.exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @returns {string|null}
 */
function load() {
  let r;
  try {
    r = module.exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
module.exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @returns {LocalStorage}
 */
function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
