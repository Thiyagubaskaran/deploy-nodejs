'use strict';

/* eslint no-invalid-this: 1 */

// Default error message for incompatible bind arguments
const ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';

// toString method for checking if an object is a function
const toStr = Object.prototype.toString;

// Check if an object is a function
const isFunction = obj => toStr.apply(obj) === '[object Function]';

// Concatenate two arrays
const concatty = (a, b) => a.concat(b);

// Slice an array-like object from a given offset
const slicy = (arrLike, offset) => arrLike.slice(offset || 0);

// Join array elements with a given joiner
const joiny = (arr, joiner) => arr.join(joiner);

// The bind function
module.exports = function bind(that) {
    // Check if the target is a function
    if (!isFunction(this)) {
        throw new TypeError(ERROR_MESSAGE + this);
    }

    // Get the target function arguments, excluding the target
    const args = slicy(arguments, 1);

    // The bound function
    const bound = function () {
        // If the bound function is called with new, apply the target function
        // with the bound this value and all arguments
        if (this instanceof bound) {
            const result = this.target.apply(
                this,
                concatty(this.args, arguments)
            );
            // If the result is an object, return it; otherwise, return the this value
            return Object(result) === result ? result : this;
        }
        // Otherwise, apply the target function with the provided this value
        // and all arguments
        return this.target.apply(
            that,
            concatty(this.args, arguments)
        );
    };

    // The length of the bound function
    const boundLength = Math.max(0, this.length - args.length);

    // The arguments for the bound function
    const boundArgs = [];
    for (let i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    // Create the bound function
    bound.prototype = Object.create(this.prototype);
    bound.prototype.constructor = bound;
    bound.target = this;
    bound.args = args;

    // Return the bound function
    return bound;
};
