const expandIPv6 = (string, parts) => {
  const colonCount = (string.match(/:/g) || []).length;
  if (string.substr(0, 2) === '::') {
    colonCount--;
  }
  if (string.substr(-2, 2) === '::') {
    colonCount--;
  }
  if (colonCount > parts) {
    return null;
  }
  const replacementCount = parts - colonCount;
  const replacement = ':'.repeat(replacementCount);
  string = string.replace('::', replacement);
  if (string[0] === ':') {
    string = string.slice(1);
  }
  if (string[string.length - 1] === ':') {
    string = string.slice(0, -1);
  }
  parts = string.split(":").map(x => parseInt(x, 16));
  return {
    parts,
    zoneId: (string.match(/%[0-9a-z]{1,}/) || [])[0] || ''
  };
};

const ipv6Regexes = {
  zoneIndex: /%[0-9a-z]{1,}/i,
  "native": /^(::)?(([0-9a-f]+:?)+)([0-9a-f]+)?(::)?(%[0-9a-z]{1,})?$/i,
  transitional: /^(([0-9a-f]+:?)+)([0-9a-f]+:?)([0-9a-f]+:?)([0-9a-f]+:?)(%[0-9a-z]{1,})?$/i
};

const ipv6Part = '(?:[0-9a-f]+::?)+';

const ipv4Part = '(0?\\d+|0x[a-f0-9]+)';

const ipv4Regexes = {
  fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
  longValue: new RegExp("^" + ipv4Part + "$", 'i')
};

const matchCIDR = (first, second, partSize, cidrBits) => {
  if (first.length !== second.length) {
    throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
  }
  let part = 0;
  while (cidrBits > 0) {
    const shift = partSize - cidrBits;
    if (shift < 0) {
      shift = 0;
    }
    if (first[part] >> shift !== second[part] >> shift) {
      return false;
    }
    cidrBits -= partSize;
    part += 1;
  }
  return true;
};

const ipaddr = {
  subnetMatch(address, rangeList, defaultName) {
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (const rangeName in rangeList) {
      const rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (let k = 0; k < rangeSubnets.length; k++) {
        const subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return default
