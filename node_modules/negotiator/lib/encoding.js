/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module exports.
 * @public
 */

const preferredEncodings = (accept, provided) => {
  const accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullEncoding);
  }

  const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));

  return priorities.filter(isQuality).sort(compareSpecs).map((priority) => provided[priorities.indexOf(priority)]);
};

module.exports = {
  preferredEncodings
};

/**
 * Module variables.
 * @private
 */

const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

const parseAcceptEncoding = (accept) => {
  const accepts = accept.split(',');
  let hasIdentity = false;
  let minQuality = 1;

  for (let i = 0, j = 0; i < accepts.length; i++) {
    const encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  accepts.length = j;

  return accepts;
};

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

const parseEncoding = (str, i) => {
  const match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  const encoding = match[1];
  let q = 1;
  if (match[2]) {
    const params = match[2].split(';');
    for (let j = 0; j < params.length; j++) {
      const p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding,
    q,
    i
  };
};

/**
 * Get the priority of an encoding.
 * @private
 */

const getEncodingPriority = (encoding, accepted, index) => {
  let priority = { o: -1, q: 0, s: 0 };

  for (let i = 0; i < accepted.length; i++) {
    const spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
};

/**
 * Get the specificity of the encoding.
 * @private
 */

const specify = (encoding, spec, index) => {
  let s = 0;
  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
    s |= 1;
  } else if (spec.encoding !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s
  };
};

/**
 * Compare two specs.
 * @private
 */

const compareSpecs = (a, b) => (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;

/**
 * Get full encoding string.
 * @private
 */

const getFullEncoding = (spec) => spec.encoding;

/**
 * Check if a spec has any quality.
 * @private
 */

const isQuality = (spec) => spec.q > 0;
