import { EventEmitter } from 'events';
import { connect } from 'cloudflare:sockets';
import { TextDecoder } from 'util';

class CloudflareSocketConnection extends EventEmitter {
  constructor(private socket: CloudflareSocket, private decoder: TextDecoder) {
    super();
  }

  async listen() {
    try {
      while (!this.socket.destroyed) {
        const { done, value } = await this.socket._cfReader.read();
        if (done) break;
        this.emit('data', this.decoder.decode(value));
      }
    } catch (error) {
      this.emit('error', error);
    } finally {
      this.emit('close');
    }
  }
}

class CloudflareSocket extends EventEmitter {
  _cfSocket: any;
  _cfWriter: any;
  _cfReader: any;
  ssl: boolean;
  destroyed: boolean;
  _upgrading: boolean;
  _upgraded: boolean;

  constructor(ssl: boolean) {
    super();
    this.ssl = ssl;
    this.destroyed = false;
    this._upgrading = false;
    this._upgraded = false;
  }

  setNoDelay() {
    return this;
  }

  setKeepAlive() {
    return this;
  }

  ref() {
    return this;
  }

  unref() {
    return this;
  }

  async connect(port: number, host: string, connectListener?: () => void) {
    try {
      if (connectListener) this.once('connect', connectListener);
      const options = this.ssl ? { secureTransport: 'starttls' } : {};
      this._cfSocket = await connect(`${host}:${port}`, options);
      this._cfWriter = this._cfSocket.writable.getWriter();
      this._addClosedHandler();
      this._cfReader = this._cfSocket.readable.getReader();
      if (this.ssl) {
        await this._listenOnce();
      } else {
        await this._listen();
      }
      await this._cfWriter.ready;
      this.emit('connect');
      return new CloudflareSocketConnection(this, new TextDecoder());
    } catch (error) {
      console.error(error);
      this.emit('error', error);
    }
  }

  async _listen() {
    while (!this.destroyed) {
      const { done, value } = await this._cfReader.read();
      if (done) break;
      this.emit('data', Buffer.from(value));
    }
  }

  async _listenOnce() {
    const { done, value } = await this._cfReader.read();
    this.emit('data', Buffer.from(value));
  }

  write(data: any, encoding = 'utf8', callback = () => { }) {
    if (data.length === 0) return callback();
    if (typeof data === 'string') data = Buffer.from(data, encoding);
    this._cfWriter.write(data).then(() => {
      callback();
    }, (err) => {
      callback(err);
    });
    return true;
  }

  end(data = Buffer.alloc(0), encoding = 'utf8', callback = () => { }) {
    this.write(data, encoding, (err) => {
      this._cfSocket.close();
      if (callback) callback(err);
    });
    return this;
  }

  destroy(reason: string) {
    this.destroyed = true;
    return this.end();
  }

  startTls(options: any) {
    if (this._upgraded) {
      this.emit('error', 'Cannot call `startTls()` more than once on a socket');
      return;
    }
    this._cfWriter.releaseLock();
    this._cfReader.releaseLock();
    this._upgrading = true;
    this._cfSocket = this._cfSocket.startTls(options);
    this._cfWriter = this._cfSocket.writable.getWriter();
    this._cfReader = this._cfSocket.readable.getReader();
    this._addClosedHandler();
    this._listen().catch((e) => this.emit('error', e));
  }

  _addClosedHandler() {
    this._cfSocket.closed.then(() => {
      if (!this._upgrading) {
        this._cfSocket = null;
        this.emit('close');
      } else {
        this._upgrading = false;
        this._upgraded = true;
      }
    }).catch((e) => this.emit('error', e));
  }
}

const debug = false;

function log(...args: any[]) {
  if (debug) console.log(...args);
}

export { CloudflareSocket };
