'use strict'

const { expect } = require('expect.js')
const { EventEmitter } = require('events')
const { describe, it } = require('mocha')
const { Pool } = require('../')

describe('Pool events', () => {
  it('should emit `connect` before callback', (done) => {
    const pool = new Pool()
    let emittedClient

    pool.on('connect', (client) => {
      emittedClient = client
    })

    pool.connect((err, client, release) => {
      if (err) return done(err)
      release()
      pool.end()
      expect(client).to.be(emittedClient)
      done()
    })
  })

  it('should emit `connect` only with a successful connection', () => {
    const pool = new Pool({
      Client: mockClient({
        connect: (cb) => {
          process.nextTick(() => {
            cb(new Error('bad news'))
          })
        },
      }),
    })

    return pool
      .connect()
      .then(() => {
        throw new Error('should never get here')
      })
      .catch((e) => expect(e.message).to.equal('bad news'))
  })

  it('should emit `acquire` every time a client is acquired', (done) => {
    const pool = new Pool()
    let acquireCount = 0

    pool.on('acquire', (client) => {
      expect(client).to.be.ok()
      acquireCount++
    })

    for (let i = 0; i < 10; i++) {
      pool.connect(() => {})
      pool.query('SELECT now()')
    }

    setTimeout(() => {
      expect(acquireCount).to.be(20)
      pool.end(done)
    }, 100)
  })

  it('should emit `release` every time a client is released', (done) => {
    const pool = new Pool()
    let releaseCount = 0

    pool.on('release', (err, client) => {
      expect(err).not.to.be.instanceOf(Error)
      expect(client).to.be.ok()
      releaseCount++
    })

    const promises = []
    for (let i = 0; i < 10; i++) {
      pool.connect(() => {})
      promises.push(pool.query('SELECT now()'))
    }

    Promise.all(promises).then(() => {
      pool.end(() => {
        expect(releaseCount).to.be(20)
        done()
      })
    })
  })

  it('should emit `release` with an error if client is released due to an error', (done) => {
    const pool = new Pool()

    pool.connect((err, client, release) => {
      expect(err).to.equal(undefined)
      const releaseError = new Error('problem')

      pool.once('release', (err, errClient) => {
        expect(err).to.equal(releaseError)
        expect(errClient).to.equal(client)
        pool.end(done)
      })

      release(releaseError)
    })
  })

  it('should emit `error` and `client` if an idle client in the pool hits an error', (done) => {
    const pool = new Pool()

    pool.connect((err, client) => {
      expect(err).to.equal(undefined)
      client.release()

      setImmediate(() => {
        client.emit('error', new Error('problem'))
      })

      pool.once('error', (err, errClient) => {
        expect(err.message).to.equal('problem')
        expect(errClient).to.equal(client)
        done()
      })
    })
  })
})

function mockClient(methods) {
  return function () {
    const client = new EventEmitter()
    Object.assign(client, methods)
    return client
  }
}

