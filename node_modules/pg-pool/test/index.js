'use strict'
const { Client } = require('pg')
const { expect } = require('chai')
const _ = require('lodash')

describe('pool', function () {
  describe('with callbacks', function () {
    let pool

    beforeEach(function () {
      pool = new Pool()
    })

    afterEach(function (done) {
      pool.end(done)
    })

    it('works totally unconfigured', function (done) {
      pool.connect(function (err, client, release) {
        if (err) return done(err)
        client.query('SELECT NOW()', function (err, res) {
          release()
          if (err) return done(err)
          expect(res.rows).to.have.length(1)
          done()
        })
      })
    })

    it('passes props to clients', function (done) {
      const config = { binary: true }
      pool = new Pool(config)
      pool.connect(function (err, client, release) {
        release()
        if (err) return done(err)
        expect(client.binary).to.eql(true)
        done()
      })
    })

    it('can run a query with a callback without parameters', function (done) {
      pool.query('SELECT 1 as num', function (err, res) {
        expect(res.rows[0]).to.eql({ num: 1 })
        pool.end(function () {
          done(err)
        })
      })
    })

    it('can run a query with a callback', function (done) {
      pool.query('SELECT $1::text as name', ['brianc'], function (err, res) {
        expect(res.rows[0]).to.eql({ name: 'brianc' })
        pool.end(function () {
          done(err)
        })
      })
    })

    it('passes connection errors to callback', function (done) {
      const pool = new Pool({ port: 53922 })
      pool.query('SELECT $1::text as name', ['brianc'], function (err, res) {
        expect(res).to.be.undefined
        expect(err).to.be.an.instanceOf(Error)
        // a connection error should not polute the pool with a dead client
        expect(pool.totalCount).to.equal(0)
        pool.end(function () {
          done()
        })
      })
    })

    it('does not pass client to error callback', function (done) {
      const pool = new Pool({ port: 58242 })
      pool.connect(function (err, client, release) {
        expect(err).to.be.an.instanceOf(Error)
        expect(client).to.be.undefined
        expect(release).to.be.a('function')
        pool.end(done)
      })
    })

    it('removes client if it errors in background', function (done) {
      pool.connect(function (err, client, release) {
        release()
        if (err) return done(err)
        client.testString = 'foo'
        setTimeout(function () {
          client.emit('error', new Error('on purpose'))
        }, 10)
      })
      pool.on('error', function (err) {
        expect(err.message).to.be.equal('on purpose')
        expect(err.client).to.not.be.undefined
        expect(err.client.testString).to.be.equal('foo')
        err.client.connection.stream.on('end', function () {
          pool.end(done)
        })
      })
    })

    it('should not change given options', function (done) {
      const options = { max: 10 }
      pool = new Pool(options)
      pool.connect(function (err, client, release) {
        release()
        if (err) return done(err)
        expect(options).to.eql({ max: 10 })
        pool.end(done)
      })
    })

    it('does not create promises when connecting', function (done) {
      pool.connect(function (err, client, release) {
        release()
        if (err) return done(err)
        pool.end(done)
      })
    })

    it('does not create promises when querying', function (done) {
      pool.query('SELECT 1 as num', function (err) {
        pool.end(function () {
          done(err)
        })
      })
    })

    it('does not create promises when ending', function (done) {
      pool.end(done)
    })

    it('never calls callback syncronously', function (done) {
      pool.connect((err, client) => {
        if (err) throw err
        client.release()
        setImmediate(() => {
          let called = false
          pool.connect((err, client) => {
            if (err) throw err
            called = true
            client.release()
            setImmediate(() => {
              pool.end(done)
            })
          })
          expect(called).to.equal(false)
        })
      })
    })
  })

  describe('with promises', function () {
    let pool

    beforeEach(function () {
      pool = new Pool()
    })

    afterEach(function () {
      return pool.end()
    })

    it('connects, queries, and disconnects', function () {
      return pool.connect()
        .then(client => client.query('select $1::text as name', ['hi']))
        .then(res => {
          expect(res.rows).to.eql([{ name: 'hi' }])
          return client.release()
        })
        .then(() => pool.end())
    })

    it('executes a query directly', () => {
      return pool.query('SELECT $1::text as name', ['hi'])
        .then(res => {
          expect(res.rows).to.
