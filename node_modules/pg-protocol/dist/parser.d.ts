import { TransformOptions } from 'stream';
import { Mode, BackendMessage } from './messages';
import { Packet } from './parser';

type StreamOptions = TransformOptions & {
  mode: Mode;
};

type MessageCallback = (msg: BackendMessage) => void;

export class Parser {
  private buffer: Buffer;
  private bufferLength: number;
  private bufferOffset: number;
  private reader: NodeJS.ReadableStream;
  private mode: Mode;

  constructor(opts?: StreamOptions) {
    this.buffer = Buffer.alloc(0);
    this.bufferLength = 0;
    this.bufferOffset = 0;
    this.reader = (opts && opts.readableObjectMode)
      ? new stream.Transform({ objectMode: true, highWaterMark: 16 })
      : new stream.Transform({ highWaterMark: 16 });
    this.mode = opts && opts.mode || Mode.Normal;

    this.reader._transform = (data: Buffer, encoding: string, callback: Function) => {
      this.parse(data);
      callback();
    };
  }

  parse(buffer: Buffer, callback?: MessageCallback): void {
    this.buffer = Buffer.concat([this.buffer, buffer]);
    this.bufferLength = this.buffer.length;

    while (this.bufferLength - this.bufferOffset >= 4) {
      const code = this.buffer.readUInt32BE(this.bufferOffset);
      const packetLength = this.getPacketLength(code);

      if (packetLength > 0) {
        if (this.bufferLength - this.bufferOffset >= packetLength) {
          const packet = this.buffer.slice(this.bufferOffset, this.bufferOffset + packetLength);
          this.buffer = this.buffer.slice(this.bufferOffset + packetLength);
          this.bufferLength = this.buffer.length;
          this.bufferOffset = 0;

          this.handlePacket(code, packet);

          if (callback) {
            callback({ code, packet });
          }
        } else
