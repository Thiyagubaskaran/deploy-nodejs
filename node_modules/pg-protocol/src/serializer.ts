import { Writer } from './buffer-writer'

const enum Code {
  Startup = 0x70,
  Query = 0x51,
  Parse = 0x50,
  Bind = 0x42,
  Execute = 0x45,
  Flush = 0x48,
  Sync = 0x53,
  End = 0x58,
  Close = 0x43,
  Describe = 0x44,
  CopyFromChunk = 0x64,
  CopyDone = 0x63,
  CopyFail = 0x66,
}

const writer = new Writer()

const startup = (opts: Record<string, string>): Buffer => {
  writer.addInt16(3).addInt16(0)
  for (const key of Object.keys(opts)) {
    writer.addCString(key).addCString(opts[key])
  }

  writer.addCString('client_encoding').addCString('UTF8')

  const bodyBuffer = writer.flush()
  const length = bodyBuffer.length + 4

  return new Writer().addInt32(length).add(bodyBuffer).flush()
}

const requestSsl = (): Buffer => {
  const response = Buffer.allocUnsafe(8)
  response.writeInt32BE(8, 0)
  response.writeInt32BE(80877103, 4)
  return response
}

const password = (password: string): Buffer => {
  return writer.addCString(password).flush(Code.Startup)
}

const sendSASLInitialResponseMessage = (mechanism: string, initialResponse: string): Buffer => {
  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse)

  return writer.flush(Code.Startup)
}

const sendSCRAMClientFinalMessage = (additionalData: string): Buffer => {
  return writer.addString(additionalData).flush(Code.Startup)
}

const query = (text: string): Buffer => {
  return writer.addCString(text).flush(Code.Query)
}

type ParseOpts = {
  name?: string
  types?: number[]
  text: string
}

const emptyArray: any[] = []

const parse = (query: ParseOpts): Buffer => {
  const name = query.name || ''
  if (name.length > 63) {
    console.error(
      'Warning! Postgres only supports 63 characters for query names. You supplied %s (%s)',
      name,
      name.length
    )
    console.error(
      'This can cause conflicts and silent errors executing queries'
    )
  }

  const types = query.types || emptyArray

  const buffer = writer
    .addCString(name)
    .addCString(query.text)
    .addInt16(types.length)

  for (const type of types) {
    buffer.addInt32(type)
  }

  return writer.flush(Code.Parse)
}

type ValueMapper = (param: any, index: number) => any

type BindOpts = {
  portal?: string
  binary?: boolean
  statement?: string
  values?: any[]
  valueMapper?: ValueMapper
}

const paramWriter = new Writer()

const enum ParamType {
  String = 0,
  Binary = 1,
}

const writeValues = (values: any[], valueMapper?: ValueMapper): void => {
  for (let i = 0; i < values.length; i++) {
    const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i]
    if (mappedVal == null) {
      paramWriter.addInt16(ParamType.String).addInt32(-1)
    } else if (mappedVal instanceof Buffer) {
      paramWriter.addInt16(ParamType.Binary).addInt32(mappedVal.length).add(mappedVal)
    } else {
      paramWriter.addInt16(ParamType.String).addInt32(Buffer.byteLength(mappedVal)).addString(mappedVal)
    }
  }
}

const bind = (config: BindOpts = {}): Buffer => {
  const portal = config.portal || ''
  const statement = config.statement || ''
  const binary = config.binary || false
  const values = config.values || emptyArray
  const len = values.length

  writer.addCString(portal).addCString(statement)
  writer.addInt16(len)

  writeValues(values, config.valueMapper)

  writer.addInt16(len).add(paramWriter.flush())

  writer.addInt16(binary ? ParamType.Binary : ParamType.String)

  return writer.flush(Code.Bind)
}

type ExecOpts = {
  portal?: string
  rows?: number
}

const emptyExecute = Buffer.from([Code.Execute, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00])

const execute = (config?: ExecOpts): Buffer => {
  if (!config || (!config.portal && !config.rows)) {
    return emptyExecute
  }

  const portal = config.portal || ''
  const rows = config.rows || 0

  const portalLength = Buffer.byteLength(portal)
  const len = 4 + portalLength + 1 + 4
  const buff = Buffer.allocUnsafe(1 + len)
  buff[0] = Code.Execute
  buff.writeInt32BE(len, 1)
  buff.write(portal
