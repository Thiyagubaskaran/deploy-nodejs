'use strict'

const extend = require('xtend/mutable')

module.exports = PostgresInterval

function PostgresInterval (raw) {
  if (typeof raw !== 'string') {
    throw new Error('Input must be a string')
  }
  if (!(this instanceof PostgresInterval)) {
    return new PostgresInterval(raw)
  }
  extend(this, parse(raw))
}

const properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']
PostgresInterval.prototype.toPostgres = function () {
  const filtered = properties.filter(this.hasOwnProperty, this)

  if (this.milliseconds && filtered.indexOf('seconds') < 0) {
    filtered.push('seconds')
  }

  if (filtered.length === 0) return '0'
  return filtered
    .map(property => {
      const value = this[property] || 0

      if (property === 'seconds' && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, '')
      }

      return value + ' ' + property
    })
    .join(' ')
}

const propertiesISOEquivalent = {
  years: 'Y',
  months: 'M',
  days: 'D',
  hours: 'H',
  minutes: 'M',
  seconds: 'S'
}
const dateProperties = ['years', 'months', 'days']
const timeProperties = ['hours', 'minutes', 'seconds']

PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {
  const datePart = dateProperties
    .map(buildProperty, this)
    .join('')

  const timePart = timeProperties
    .map(buildProperty, this)
    .join('')

  return 'P' + datePart + 'T' + timePart

  function buildProperty (property) {
    const value = this[property] || 0

    if (property === 'seconds' && this.milliseconds) {
      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '')
    }

    return value + propertiesISOEquivalent[property]
  }
}

const NUMBER = '([+-]?\\d+)'
const YEAR = NUMBER + '\\s+years?'
const MONTH = NUMBER + '\\s+months?'
const DAY = NUMBER + '\\s+days?'
const TIME = '([+-])?(\\d{1,2}):(\\d{1,2}):(\\d{1,2})(\\.(\\d{1,6}))?'
const INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(regexString => '(' + regexString + ')?').join('\\s*'))

const positions = {
  years: 2,
  months: 4,
  days: 6,
  hours: 9,
  minutes: 10,
  seconds: 11,
  milliseconds: 13
}
const negatives = ['hours', 'minutes', 'seconds']

function parseMilliseconds (fraction) {
  // add omitted zeroes
  const microseconds = fraction + '000000'.slice(fraction.length)
  return parseInt(microseconds, 10) / 1000
}

function parse (interval) {
  if (!interval) return {}
  const matches = INTERVAL.exec(interval)
  let isNegative = false
  if (matches[8] === '-') {
    isNegative = true
  }
  return Object.keys(positions)
    .reduce((parsed, property) => {
      const position = positions[property]
      let value = matches[position]
      // no empty string
      if (!value) return parsed
      // milliseconds are actually microseconds (up to 6 digits)
      // with omitted trailing zeroes.
      value = property === 'milliseconds'
        ? parseMilliseconds(value)
        : parseInt(value, 10)
      // no zeros
      if (!value) return parsed
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1
      }
      parsed[property] = value
      return parsed
    }, {})
}
